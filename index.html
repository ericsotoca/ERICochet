<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E'Ricochet</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; margin: 0; padding: 10px; }
        h1 { font-size: 1.5rem; margin-bottom: 10px; }
        #game-container { 
            display: grid; 
            grid-template-columns: repeat(16, 1fr); 
            grid-template-rows: repeat(16, 1fr); 
            gap: 1px; 
            background-color: #aaa; 
            border: 4px solid #604028; 
            position: relative; 
            margin-bottom: 10px; 
            width: 90vw; 
            max-width: 640px; 
            aspect-ratio: 1; 
        }
        .cell { 
            background-color: #e8e8e8; 
            position: relative; 
            box-sizing: border-box; 
            background-image: linear-gradient(45deg, #fdfdfd 25%, transparent 25%), linear-gradient(-45deg, #fdfdfd 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #fdfdfd 75%), linear-gradient(-45deg, transparent 75%, #fdfdfd 75%); 
            background-size: 6px 6px; 
            background-position: 0 0, 0 3px, 3px -3px, -3px 0px; 
        }
        .center-square { background-color: #d3d3d3 !important; background-image: none !important; }
        .wall-top::before, .wall-bottom::before, .wall-left::after, .wall-right::after { content: ''; position: absolute; background-color: #604028; z-index: 5; }
        .wall-top::before { top: -2px; left: 0; right: 0; height: 4px; }
        .wall-bottom::before { bottom: -2px; left: 0; right: 0; height: 4px; }
        .wall-left::after { top: 0; bottom: 0; left: -2px; width: 4px; }
        .wall-right::after { top: 0; bottom: 0; right: -2px; width: 4px; }
        .robot { 
            width: 75%; 
            height: 75%; 
            border-radius: 50%; 
            position: absolute; 
            top: 12.5%; 
            left: 12.5%; 
            z-index: 10; 
            box-shadow: 1px 1px 3px rgba(0,0,0,0.5); 
            border: 1px solid rgba(0,0,0,0.3); 
            overflow: hidden; 
        }
        .robot::after { content: ''; position: absolute; width: 30%; height: 30%; background-color: white; top: 50%; left: 50%; transform: translate(-50%, -50%); clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .blue { background-color: #4169E1; } .red { background-color: #DC143C; } .green { background-color: #32CD32; } .yellow { background-color: #FFD700; }
        .target { 
            width: 75%; 
            height: 75%; 
            position: absolute; 
            top: 12.5%; 
            left: 12.5%; 
            z-index: 1; 
            background-size: contain; 
            background-repeat: no-repeat; 
            background-position: center; 
        }
        .target.blue { background-color: #4169E1; } .target.red { background-color: #DC143C; } .target.green { background-color: #32CD32; } .target.yellow { background-color: #FFD700; }
        .target-circle { border-radius: 50%; } .target-triangle { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); } .target-square { clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); } .target-hexagon { clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); } .target-star { clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); }
        .target.active { box-shadow: 0 0 0 3px black; }
        #info { margin-top: 0; font-size: 1rem; font-weight: bold; margin-bottom: 5px; min-height: 20px; text-align: center; }
        #moves { margin-top: 5px; font-size: 1rem; text-align: center; }
        #controls { text-align: center; margin-bottom: 10px; }
        #controls button { margin: 5px; padding: 8px 12px; font-size: 0.9rem; color: white; border: none; cursor: pointer; border-radius: 4px; }
        #start-game-button { background-color: #28a745; } #start-game-button:hover { background-color: #218838; }
        #reset-walls-button { background-color: #ffc107; color: #333; } #reset-walls-button:hover { background-color: #e0a800; }
        #help-button { background-color: #17a2b8; } #help-button:hover { background-color: #138496; }
        #restart-button { background-color: #007bff; } #restart-button:hover { background-color: #0056b3; }
        #robot-selector { display: flex; gap: 10px; margin-bottom: 10px; }
        .robot-button { 
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            border: 2px solid #333; 
            cursor: pointer; 
            transition: all 0.3s; 
        }
        .robot-button.active { 
            animation: pulse 1s infinite; 
            box-shadow: 0 0 10px rgba(0, 0, 255, 0.8); 
        }
        @keyframes pulse { 
            0% { transform: scale(1); } 
            50% { transform: scale(1.1); } 
            100% { transform: scale(1); } 
        }
        #mobile-controls { display: none; flex-wrap: wrap; justify-content: center; gap: 5px; }
        #mobile-controls button { padding: 10px; font-size: 1rem; width: 60px; }
        .editing-mode .cell { cursor: pointer; }
        .editing-mode .cell:hover { background-color: #d0d0f0; opacity: 0.8; }
        @media (max-width: 600px) { 
            #mobile-controls { display: flex; } 
            #info { font-size: 0.9rem; }
            #moves { font-size: 0.9rem; }
            .robot-button { width: 30px; height: 30px; }
        }
    </style>
</head>
<body>
<h1>E'Ricochet</h1>
<div id="game-container"></div>
<div id="info">Cliquez près des bords pour ajouter/enlever des murs. Appuyez sur "Démarrer la Partie".</div>
<div id="moves">Coups : 0</div>
<div id="robot-selector" style="display: none;">
    <div class="robot-button red" data-color="red" onclick="selectRobot('red')"></div>
    <div class="robot-button green" data-color="green" onclick="selectRobot('green')"></div>
    <div class="robot-button blue" data-color="blue" onclick="selectRobot('blue')"></div>
    <div class="robot-button yellow" data-color="yellow" onclick="selectRobot('yellow')"></div>
</div>
<div id="controls">
    <button id="start-game-button" onclick="startGame()">Démarrer la Partie</button>
    <button id="reset-walls-button" onclick="resetWallsToDefault()">Réinitialiser Murs</button>
    <button id="help-button">Aide</button>
    <button id="restart-button" onclick="restartGame()" style="display: none;">Nouveau Tour</button>
</div>
<div id="mobile-controls">
    <button onclick="moveRobot(activeRobot, 0, -1)">↑</button>
    <button onclick="moveRobot(activeRobot, -1, 0)">←</button>
    <button onclick="moveRobot(activeRobot, 1, 0)">→</button>
    <button onclick="moveRobot(activeRobot, 0, 1)">↓</button>
    <button onclick="undoMove()">U</button>
</div>
<script>
    const GRID_SIZE = 16;
    const WALL_CLICK_MARGIN = 10;
    const container = document.getElementById('game-container');
    const info = document.getElementById('info');
    const movesDisplay = document.getElementById('moves');
    const startGameButton = document.getElementById('start-game-button');
    const resetWallsButton = document.getElementById('reset-walls-button');
    const restartButton = document.getElementById('restart-button');
    const helpButton = document.getElementById('help-button');
    const robotSelector = document.getElementById('robot-selector');
    let board = [];
    let robots = [];
    let targets = [
        { shape: 'circle', color: 'blue', x: 5, y: 1 }, { shape: 'square', color: 'yellow', x: 7, y: 2 },
        { shape: 'star', color: 'red', x: 3, y: 5 }, { shape: 'hexagon', color: 'green', x: 5, y: 6 },
        { shape: 'circle', color: 'yellow', x: 2, y: 8 }, { shape: 'triangle', color: 'blue', x: 3, y: 11 },
        { shape: 'star', color: 'green', x: 5, y: 12 }, { shape: 'triangle', color: 'blue', x: 6, y: 14 },
        { shape: 'circle', color: 'red', x: 11, y: 2 }, { shape: 'triangle', color: 'green', x: 14, y: 3 },
        { shape: 'star', color: 'yellow', x: 12, y: 6 }, { shape: 'star', color: 'blue', x: 11, y: 10 },
        { shape: 'hexagon', color: 'yellow', x: 10, y: 11 }, { shape: 'triangle', color: 'red', x: 14, y: 12 },
        { shape: 'triangle', color: 'yellow', x: 5, y: 3 }
    ];
    let currentTarget = null;
    let activeRobot = null;
    let moves = 0;
    let moveHistory = [];
    let isEditing = true;

    function traduireCouleur(couleurAnglais) {
        switch (couleurAnglais) {
            case 'red': return 'rouge'; case 'green': return 'vert';
            case 'blue': return 'bleu'; case 'yellow': return 'jaune';
            default: return couleurAnglais;
        }
    }
    function traduireForme(formeAnglais) {
        switch (formeAnglais) {
            case 'circle': return 'cercle'; case 'triangle': return 'triangle';
            case 'square': return 'carré'; case 'hexagon': return 'hexagone';
            case 'star': return 'étoile'; default: return formeAnglais;
        }
    }

    function createEmptyBoard() {
        board = [];
        for (let y = 0; y < GRID_SIZE; y++) {
            let row = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                let walls = { top: false, right: false, bottom: false, left: false };
                if (x === 0) walls.left = true;
                if (x === GRID_SIZE - 1) walls.right = true;
                if (y === 0) walls.top = true;
                if (y === GRID_SIZE - 1) walls.bottom = true;
                row.push(walls);
            }
            board.push(row);
        }
        addWall(7, 6, 'bottom'); addWall(8, 6, 'bottom');
        addWall(6, 7, 'right'); addWall(6, 8, 'right');
        addWall(8, 7, 'right'); addWall(8, 8, 'right');
        addWall(7, 8, 'bottom'); addWall(8, 8, 'bottom');
    }

    function addDefaultInternalWalls() {
        addWall(11, 2, 'bottom'); addWall(11, 2, 'right');
        addWall(7, 2, 'bottom'); addWall(7, 2, 'right');
        addWall(5, 1, 'bottom'); addWall(5, 1, 'left');
        addWall(5, 3, 'top'); addWall(5, 3, 'right');
        addWall(3, 5, 'bottom'); addWall(3, 5, 'right');
        addWall(5, 6, 'top'); addWall(5, 6, 'right');
        addWall(2, 8, 'top'); addWall(2, 8, 'left');
        addWall(3, 11, 'bottom'); addWall(3, 11, 'right');
        addWall(5, 12, 'top'); addWall(5, 12, 'left');
        addWall(6, 14, 'top'); addWall(6, 14, 'right');
        addWall(14, 3, 'bottom'); addWall(14, 3, 'left');
        addWall(12, 6, 'top'); addWall(12, 6, 'left');
        addWall(11, 10, 'bottom'); addWall(11, 10, 'right');
        addWall(10, 11, 'top'); addWall(10, 11, 'right');
        addWall(14, 12, 'top'); addWall(14, 12, 'left');
        addWall(1, 0, 'bottom'); addWall(0, 1, 'right');
        addWall(14, 0, 'bottom'); addWall(14, 1, 'right');
        addWall(1, 14, 'bottom'); addWall(0, 14, 'right');
        addWall(14, 14, 'bottom'); addWall(14, 14, 'right');
    }

    function addWall(x, y, side) {
        if (isOutOfBounds(x, y) || isBoundaryWall(x, y, side)) return;
        if (side === 'top' && y > 0) { board[y][x].top = true; board[y - 1][x].bottom = true; }
        else if (side === 'bottom' && y < GRID_SIZE - 1) { board[y][x].bottom = true; board[y + 1][x].top = true; }
        else if (side === 'left' && x > 0) { board[y][x].left = true; board[y][x - 1].right = true; }
        else if (side === 'right' && x < GRID_SIZE - 1) { board[y][x].right = true; board[y][x + 1].left = true; }
    }

    function removeWall(x, y, side) {
        if (isOutOfBounds(x, y) || isBoundaryWall(x, y, side) || isCenterWall(x, y, side)) return;
        if (side === 'top' && y > 0) { board[y][x].top = false; board[y - 1][x].bottom = false; }
        else if (side === 'bottom' && y < GRID_SIZE - 1) { board[y][x].bottom = false; board[y + 1][x].top = false; }
        else if (side === 'left' && x > 0) { board[y][x].left = false; board[y][x - 1].right = false; }
        else if (side === 'right' && x < GRID_SIZE - 1) { board[y][x].right = false; board[y][x + 1].left = false; }
    }

    function toggleWall(x, y, side) {
        if (isOutOfBounds(x, y) || isBoundaryWall(x, y, side) || isCenterWall(x, y, side) || isEssentialEdgeWall(x, y, side)) return;
        let wallExists = side === 'top' ? board[y][x].top : side === 'bottom' ? board[y][x].bottom : side === 'left' ? board[y][x].left : board[y][x].right;
        if (wallExists) removeWall(x, y, side);
        else addWall(x, y, side);
        renderBoard();
    }

    function isOutOfBounds(x, y) { return x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE; }
    function isBoundaryWall(x, y, side) { return (side === 'top' && y === 0) || (side === 'bottom' && y === GRID_SIZE - 1) || (side === 'left' && x === 0) || (side === 'right' && x === GRID_SIZE - 1); }
    function isCenterWall(x, y, side) {
        if (side === 'bottom' && y === 8 && (x === 7 || x === 8)) return true;
        if (side === 'top' && y === 7 && (x === 7 || x === 8)) return true;
        if (side === 'right' && x === 6 && (y === 7 || y === 8)) return true;
        if (side === 'left' && x === 9 && (y === 7 || y === 8)) return true;
        return false;
    }
    function isEssentialEdgeWall(x, y, side) {
        if ((side === 'bottom' && x === 1 && y === 0) || (side === 'top' && x === 1 && y === 1)) return true;
        if ((side === 'right' && x === 0 && y === 1) || (side === 'left' && x === 1 && y === 1)) return true;
        if ((side === 'bottom' && x === 14 && y === 0) || (side === 'top' && x === 14 && y === 1)) return true;
        if ((side === 'right' && x === 14 && y === 1) || (side === 'left' && x === 15 && y === 1)) return true;
        if ((side === 'bottom' && x === 1 && y === 14) || (side === 'top' && x === 1 && y === 15)) return true;
        if ((side === 'right' && x === 0 && y === 14) || (side === 'left' && x === 1 && y === 14)) return true;
        if ((side === 'bottom' && x === 14 && y === 14) || (side === 'top' && x === 14 && y === 15)) return true;
        if ((side === 'right' && x === 14 && y === 14) || (side === 'left' && x === 15 && y === 14)) return true;
        return false;
    }

    function renderBoard() {
        container.innerHTML = '';
        container.className = isEditing ? 'editing-mode' : '';
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                let cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                if (board[y]?.[x]?.top) cell.classList.add('wall-top');
                if (board[y]?.[x]?.right) cell.classList.add('wall-right');
                if (board[y]?.[x]?.bottom) cell.classList.add('wall-bottom');
                if (board[y]?.[x]?.left) cell.classList.add('wall-left');
                if ((x >= 7 && x <= 8) && (y >= 7 && y <= 8)) cell.classList.add('center-square');
                if (isEditing) cell.addEventListener('click', handleCellClick);
                container.appendChild(cell);
            }
        }
        if (!isEditing) {
            targets.forEach(target => {
                if (!isOutOfBounds(target.x, target.y)) {
                    let cellIndex = target.y * GRID_SIZE + target.x;
                    if (container.children[cellIndex]) {
                        let cell = container.children[cellIndex];
                        let targetDiv = document.createElement('div');
                        const shapeClass = target.shape ? `target-${target.shape}` : 'target-square';
                        targetDiv.className = `target ${shapeClass} ${target.color}`;
                        if (target === currentTarget) targetDiv.classList.add('active');
                        cell.appendChild(targetDiv);
                    }
                }
            });
            robots.forEach(robot => {
                if (!isOutOfBounds(robot.x, robot.y)) {
                    let cellIndex = robot.y * GRID_SIZE + robot.x;
                    if (container.children[cellIndex]) {
                        let cell = container.children[cellIndex];
                        let robotDiv = document.createElement('div');
                        robotDiv.className = `robot ${robot.color}`;
                        if (robot === activeRobot) {
                            robotDiv.style.outline = '3px solid white';
                            robotDiv.style.outlineOffset = '-3px';
                        }
                        cell.appendChild(robotDiv);
                    }
                }
            });
        }
        updateRobotSelector();
    }

    function handleCellClick(event) {
        if (!isEditing) return;
        const cell = event.currentTarget;
        const x = parseInt(cell.dataset.x);
        const y = parseInt(cell.dataset.y);
        const rect = cell.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        const cellSize = rect.width;
        if (clickY < WALL_CLICK_MARGIN) toggleWall(x, y, 'top');
        else if (clickY > cellSize - WALL_CLICK_MARGIN) toggleWall(x, y, 'bottom');
        else if (clickX < WALL_CLICK_MARGIN) toggleWall(x, y, 'left');
        else if (clickX > cellSize - WALL_CLICK_MARGIN) toggleWall(x, y, 'right');
    }

    function selectRobot(color) {
        if (isEditing) return;
        activeRobot = robots.find(r => r.color === color);
        updateInfo();
        renderBoard();
    }

    function updateRobotSelector() {
        const buttons = robotSelector.querySelectorAll('.robot-button');
        buttons.forEach(button => {
            const color = button.dataset.color;
            button.classList.toggle('active', activeRobot && activeRobot.color === color);
        });
    }

    function handleKeyPress(e) {
        if (isEditing) return;
        let key = e.key.toUpperCase();
        if (key === 'R') selectRobot('red');
        else if (key === 'G') selectRobot('green');
        else if (key === 'B') selectRobot('blue');
        else if (key === 'Y') selectRobot('yellow');
        else if (key === 'U') undoMove();
        else if (key === 'ESCAPE') window.close();
        else if (activeRobot) {
            if (e.key === 'ArrowUp') moveRobot(activeRobot, 0, -1);
            else if (e.key === 'ArrowDown') moveRobot(activeRobot, 0, 1);
            else if (e.key === 'ArrowLeft') moveRobot(activeRobot, -1, 0);
            else if (e.key === 'ArrowRight') moveRobot(activeRobot, 1, 0);
        }
    }

    function selectTarget() {
        const reachableTargets = targets.filter(target => {
            const x = target.x;
            const y = target.y;
            if (isOutOfBounds(x, y)) return false;
            const cell = board[y]?.[x];
            return cell && (cell.top || cell.bottom || cell.left || cell.right);
        });
        if (reachableTargets.length === 0) {
            info.textContent = "Aucune cible valide/atteignable trouvée avec les murs actuels !";
            currentTarget = null;
            return;
        }
        currentTarget = reachableTargets[Math.floor(Math.random() * reachableTargets.length)];
        updateInfo();
    }

    function updateInfo() {
        if (isEditing) {
            info.textContent = "Cliquez près des bords pour ajouter/enlever des murs. Appuyez sur 'Démarrer la Partie'.";
        } else if (!currentTarget) {
            info.textContent = "Pas de cible sélectionnée ou disponible.";
        } else {
            const cibleCouleur = traduireCouleur(currentTarget.color);
            const cibleForme = traduireForme(currentTarget.shape);
            const targetCoords = `(${currentTarget.x}, ${currentTarget.y})`;
            if (activeRobot) {
                const robotCouleur = traduireCouleur(activeRobot.color);
                info.textContent = `Amenez le robot ${cibleCouleur} sur la cible ${cibleCouleur} (${cibleForme} ${cibleCouleur} à ${targetCoords}). Robot actif : ${robotCouleur}. Tous les déplacements comptent.`;
            } else {
                info.textContent = `Amenez le robot ${cibleCouleur} sur la cible ${cibleCouleur} (${cibleForme} ${cibleCouleur} à ${targetCoords}). Cliquez sur une couleur pour sélectionner un robot.`;
            }
        }
    }

    function moveRobot(robot, dx, dy) {
        if (!robot || isEditing) return;
        let x = robot.x;
        let y = robot.y;
        let startX = x;
        let startY = y;
        while (true) {
            let nextX = x + dx;
            let nextY = y + dy;
            if (isOutOfBounds(x, y) || !board[y] || !board[y][x]) break;
            if (dx > 0 && board[y][x].right) break;
            if (dx < 0 && board[y][x].left) break;
            if (dy > 0 && board[y][x].bottom) break;
            if (dy < 0 && board[y][x].top) break;
            if (isOutOfBounds(nextX, nextY)) break;
            let collision = robots.some(r => r !== robot && r.x === nextX && r.y === nextY);
            if (collision) break;
            x = nextX;
            y = nextY;
        }
        if (x !== startX || y !== startY) {
            let move = { robot, fromX: startX, fromY: startY, toX: x, toY: y };
            robot.x = x;
            robot.y = y;
            moves++;
            movesDisplay.textContent = `Coups : ${moves}`;
            moveHistory.push(move);
            renderBoard();
            checkWin();
        }
    }

    function undoMove() {
        if (isEditing || moveHistory.length === 0) return;
        let lastMove = moveHistory.pop();
        lastMove.robot.x = lastMove.fromX;
        lastMove.robot.y = lastMove.fromY;
        moves--;
        movesDisplay.textContent = `Coups : ${moves}`;
        updateInfo();
        renderBoard();
    }

    function checkWin() {
        if (isEditing || !currentTarget) return;
        const winner = robots.find(r => r.x === currentTarget.x && r.y === currentTarget.y);
        if (winner) {
            const couleurGagnant = traduireCouleur(winner.color);
            const couleurCible = traduireCouleur(currentTarget.color);
            const formeCible = traduireForme(currentTarget.shape);
            if (winner.color === currentTarget.color) {
                info.textContent = `Correct ! Le robot ${couleurGagnant} a atteint la cible ${formeCible} ${couleurCible} en ${moves} coups ! Appuyez sur 'Nouveau Tour'.`;
                document.removeEventListener('keydown', handleKeyPress);
                restartButton.focus();
            } else {
                info.textContent = `Un robot ${couleurGagnant} est sur la cible ${couleurCible}. Seule la couleur ${couleurCible} peut atteindre cette cible !`;
            }
        }
    }

    function startGame() {
        isEditing = false;
        startGameButton.style.display = 'none';
        resetWallsButton.style.display = 'none';
        helpButton.style.display = 'inline-block'; // Bouton Aide reste visible
        restartButton.style.display = 'inline-block';
        robotSelector.style.display = 'flex';
        robots = [
            { color: 'blue', x: 10, y: 4 },
            { color: 'red', x: 4, y: 15 },
            { color: 'green', x: 14, y: 14 },
            { color: 'yellow', x: 4, y: 14 }
        ];
        moves = 0;
        movesDisplay.textContent = `Coups : ${moves}`;
        moveHistory = [];
        activeRobot = null;
        currentTarget = null;
        selectTarget();
        renderBoard();
        document.addEventListener('keydown', handleKeyPress);
    }

    function resetWallsToDefault() {
        if (!isEditing) return;
        createEmptyBoard();
        addDefaultInternalWalls();
        renderBoard();
        updateInfo();
    }

    function restartGame() {
        if (isEditing) return;
        moves = 0;
        movesDisplay.textContent = `Coups : ${moves}`;
        moveHistory = [];
        activeRobot = null;
        currentTarget = null;
        robots = [
            { color: 'blue', x: 10, y: 4 },
            { color: 'red', x: 4, y: 15 },
            { color: 'green', x: 14, y: 14 },
            { color: 'yellow', x: 4, y: 14 }
        ];
        selectTarget();
        renderBoard();
        document.removeEventListener('keydown', handleKeyPress);
        document.addEventListener('keydown', handleKeyPress);
    }

    function showHelp() {
        alert(
            "Aide Ricochet Robots :\n\n" +
            "MODE ÉDITION :\n" +
            "- Cliquez près des bords d’une case pour ajouter ou enlever un mur.\n" +
            "- Les murs extérieurs, centraux et les 8 murs près des bords ne sont pas modifiables.\n" +
            "- Utilisez 'Réinitialiser Murs' pour revenir à la configuration de départ.\n" +
            "- Cliquez sur 'Démarrer la Partie' quand le plateau vous convient.\n\n" +
            "MODE JEU :\n" +
            "- But : Amener le robot de la couleur correspondante sur la cible (même couleur et forme) en un minimum de coups.\n" +
            "- Règle importante : Seule la couleur indiquée (par exemple, robot jaune pour une cible jaune) peut atteindre la cible pour gagner.\n" +
            "- Murs mobiles : Vous pouvez déplacer les autres robots pour créer des obstacles temporaires, mais ils ne peuvent pas atteindre la cible à la place du robot de la bonne couleur.\n" +
            "- Sélection Robot : Cliquez sur une couleur (ou R, V, B, J sur clavier).\n" +
            "- Déplacement : Flèches ou boutons (↑↓←→). Le robot glisse jusqu’à un obstacle. Tous les déplacements comptent.\n" +
            "- Cible : Entourée d’une bordure noire.\n" +
            "- Commandes : U (Annuler), Nouveau Tour, Échap (Quitter).\n\n" +
            "Conseil : Positionnez les robots stratégiquement pour bloquer ou guider !"
        );
    }

    function initializeApp() {
        isEditing = true;
        createEmptyBoard();
        addDefaultInternalWalls();
        renderBoard();
        startGameButton.style.display = 'inline-block';
        resetWallsButton.style.display = 'inline-block';
        helpButton.style.display = 'inline-block';
        restartButton.style.display = 'none';
        robotSelector.style.display = 'none';
        updateInfo();
        document.removeEventListener('keydown', handleKeyPress);
        helpButton.addEventListener('click', showHelp);
    }

    initializeApp();
</script>
</body>
</html>
